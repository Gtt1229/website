(window.webpackJsonp=window.webpackJsonp||[]).push([[286],{658:function(t,o,e){"use strict";e.r(o);var n=e(42),a=Object(n.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"async"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[t._v("#")]),t._v(" Async "),e("seo")],1),t._v(" "),e("p",[t._v("Roughly, the Async approach can be described as iterating through NON-BLOCKING operations in the loop.\nAsync operation should NOT block. If async operation blocks, it makes the entire loop and the whole Async system wait for that operation to finish.\nWhile it brings in some challenges to code-writing, it also leads to better CPU utilization and some performance increase.")]),t._v(" "),e("p",[t._v("If you go with Async approach you should always make sure:")]),t._v(" "),e("ul",[e("li",[t._v("That you are using NON-BLOCKING I/O.")]),t._v(" "),e("li",[t._v("Calls that you make from within Async methods are NON-BLOCKING.")])]),t._v(" "),e("p",[t._v("All asynchronous logic in oatpp is based on "),e("RouterLink",{attrs:{to:"/api/latest/oatpp/core/async/Executor/"}},[t._v("oatpp::async::Executor")]),t._v(" and "),e("RouterLink",{attrs:{to:"/docs/oatpp-coroutines/"}},[t._v("oatpp coroutines")]),t._v(".")],1),t._v(" "),e("p",[t._v('Entities that provide Async API are named "'),e("strong",[t._v("Async")]),t._v('Entity", Async methods are named "doSomething'),e("strong",[t._v("Async")]),t._v('",\ncode-gen macros that generate Async code are named "MACRO_'),e("strong",[t._v("ASYNC")]),t._v('"')]),t._v(" "),e("p",[t._v("For better understanding and examples see "),e("RouterLink",{attrs:{to:"/docs/oatpp-coroutines/"}},[t._v("oatpp coroutines")])],1)])}),[],!1,null,null,null);o.default=a.exports}}]);